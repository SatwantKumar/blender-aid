"""
    the Blender-aid API.
    
    example:
        server = blenderaidapi.Server(("localhost", 8080))
        productions = server.getProductions()
        for production in productions:
            print(production.name)
            files = production.getFiles()
            for file in files:
                print(file.location)
                
    example2:
        server = blenderaidapi.Server(("localhost", 8080))
        production = server.getProductions()[0]
        production.getFiles(location="chars/frankie.blend")[0].rename("momo.blend")
    
"""
# the blender-aid API
# httplib if < python 3.0
# anders http.client

import httplib
import json

class BlenderAidException(Exception):
    """
        Base Exception class to be used for exception management.
    """
    def __init__(self, message):
        self.message = message
        
    def __str__(self):
        return str(self.message)

def request(binding, servicename, requestParams):
    """
        send a request to the servicename with the requestParams and result
        the response.
        
        this method does:
            1. translate the requestParams to a JSON string
            2. send the JSON string to the server/servicename
            3. receive the JSON response string
            4. translate the JSON response to the result
    """
    # 1
    request = json.dumps(requestParams)+"\r\n"
    # 2
    connection = httplib.HTTPConnection(binding[0], binding[1])
    connection.request("POST", "/service/" + servicename, request)
    # 3
    response = connection.getresponse()
    responseBytes = response.read()
    connection.close()
    # 4:
    result = json.loads(responseBytes)
    return result

class Server:
    """
        Server is the entry class to access Blender-aid functionality from
        other python sources.
        
        It can be used to automate and integrate Blender-aid into your
        production pipeline.
    """
    def __init__(self, binding):
        """
            usage:
            server = blenderaidapi.Server(("127.0.0.1", 8080))
        """
        self.binding = binding
        
    def getProductions(self, name=None, workfolder=None):
        """
            receive productions configured on the server mathing the given name and
            workfolder. When None these will be ignored.
            
            result is an array with Production classes, or an Exception
        """
        response = request(self.binding, "productions", [])
        result = []
        for jsonProduction in response:
            add = True
            if name is not None and jsonProduction["production_name"].find(name) == -1:
                add = False
            if workfolder is not None and jsonProduction["production_location"].find(workfolder) == -1:
                add = False

            if add:
                result.append(Production(self, jsonProduction))

        return result
    
    def getActiveProduction(self):
        """
            get the active production.
            return Production or None, when no production is active
        """
        response = request(self.binding, "productionview", {})
        if len(response) == 0:
            return None
        else:
            return Production(self, response[0])
        

    def addProduction(self, production):
        """
            register a production to blender-aid.
            
            Note: the new production id generated by the database
            is not updated. the production should be re-read

            Note: exception handling not implemented yet.
        """
        return request(self.binding, "addproduction", {
            "production_name":production.name,
            "production_location":production.location,
            "production_svnurl":production.svnUrl,
            "production_svnusername":production.svnUserid,
            "production_svnpassword":production.svnPassword
        })
        
    def removeProduction(self, production):
        """
            unregister a production from blender-aid
        """
        return request(self.binding, "removeproduction", {
            "production_id":production.id
        })

class RefactoringAction:
    pass

class RefactoringProcess:
    def execute(self):
        pass

class MissingLink:
    """
        object representing a missing link
    """
    def __init__(self, server, production, json):
        self.server = server
        self.production = production
        self.file_location = json["file_location"]
        self.missing_file_location = json["missing_file_location"]
        self.file_id = json["file_id"]
        self.element_id = json["element_id"]
    
    def getPossibleMatches(self):
        response = request(self.server.binding, "missinglinksolutions", {"production_id":self.production.id, "element_id":self.element_id})
        result = []
        for jsonMatch in response:
            result.append(PossibleLink(self.server, self.production, self, jsonMatch))
        return result
        
    def __str__(self):
        return "Missing link: " +self.file_location+"=>"+self.missing_file_location

class PossibleLink:
    """
        object representing a possible link to solve of a missing link
        
        server - the server instance
        production - the production instance
        missinglink - the missinglink instance
        file_id - the file id where the missing link can be linked to 
        file_name - the name of the file
        file_location - the location of the file
        match - how likely the link is
    """
    def __init__(self, server, production, missinglink, json):
        self.server = server
        self.production = production
        self.missinglink = missinglink
        self.file_id = json["file_id"]
        self.file_name = json["file_name"]
        self.file_location = json["file_location"]
        self.match = json["match"]
        
    def fix(self, execute=True):
        """
            fix the missing link by applying this link.
            
            execute -- boolean indicating if the refactoring process will be
                    executed immediatly by this call
        """
        pass
    def __str__(self):
        return "Match: "+self.file_location+" "+str(self.match)

class Production:
    """
        object representing a production
        
        id -- id of the production (key)
        name -- name of the production
        location -- absolute path to the root of the production on the filesystem
        svnUrl -- SVN url of the production
        svnUserid -- SVN userid
        svnPassword -- SVN password
        active -- is this the actice production
    """
    def __init__(self, server, jsonProduction):
        self.server=server
        self.id=jsonProduction["production_id"]
        self.name=jsonProduction["production_name"]
        self.location=jsonProduction["production_location"]
        self.active=jsonProduction["production_active"]
        self.svnUrl=jsonProduction["production_svnurl"]
        self.svnUserid=jsonProduction["production_svnuserid"]
        self.svnPassword=jsonProduction["production_svnpassword"]

    def getMissingLinks(self):
        """
            returns a list of missing links in the production.
        """
        response = request(self.server.binding, "productionview", {"production_id":self.id})
        result = []
        
        for jsonLink in response[3]:
            result.append(MissingLink(self.server, self, jsonLink))

        return result        
        
    def getFiles(self, name=None, location=None):
        """
            get a list of the files in the production. The list is filtered 
            with the given name and location.
            
            name -- part of the filename to be include in the list
            location -- part of the location of the file to be included in the 
                    list
        """
        response = request(self.server.binding, "productionview", {"production_id":self.id})
        result = []
        
        for jsonFile in response[1]:
            add = True
            if name is not None and jsonFile["file_name"].find(name) == -1:
                add = False
            if location is not None and jsonFile["file_location"].find(location) == -1:
                add = False

            if add:
                result.append(File(self.server, self, jsonFile))

        return result        

    def getDirectories(self):
        """
            get a list of directories in the production. Empty directories are 
            always excluded in the result
        """
        pass
        
    def activate(self):
        """
            activate this production (make the production the current active
            production. usable for easy retrieval.
        """
        response = request(self.server.binding, "activateproduction", {"production_id":self.id})
        return None
        
    def __str__(self):
        return "Production: "+self.name

class File:
    """
        object representing a file
        
        fields:
            id -- id of the file (key)
            location -- relative location from the production location of this
                file including the filename
            name -- filename of the file
            
            production -- Production where this file is part of
            server -- Server object what is used to retrieve this
                    object from the server.
    """
    def __init__(self, server, production, json):
        self.server = server
        self.production = production
        self.id=json["file_id"]
        self.location=json["file_location"]
        self.name=json["file_name"]
        
    def getElements(self, name=None, type=None):
        """
            get a list of elements of this file.
            
            fields:
                name -- name filter to use
                type -- type filter to use
        """
        pass
        
    def getReferences(self, referencesFrom=False):
        pass

    def rename(self, newFilename, execute=True):
        pass

    def move(self, directory, execute=True):
        pass
    
    def getDirectory(self):
        """
            get the directory where this file is located.
        """
        pass
        
    def __str__(self):
        return "File: "+self.location

class Directory:
    """
        object representing a directory
        
        fields:
            production -- production where this directory is part of
            location -- the full directory name (including parent directory)
                    from the roor location of the production
            server -- the Server object what is used to retrieve this object
    """
    def __init__(self, server, production, json):
        self.server = server
        self.production = production
        self.location=json["dir_location"]

    def rename(self, targetDirname, execute=True):
        response = request(self.server.binding, "renamedir", {"production_id":self.id, "source_directory":self.location, "target_directory_name":targetDirname})
        
        if len(response) > 0 :
           raise BlenderAidException(response[0]["message"]) 
        elif execute :
            #execute rename 

    def move(self, targetDirname, execute=True):
        response = request(self.server.binding, "movedir", {"production_id":self.id, "source_directory":self.location, "target_directory":targetDirname})
        #response controleren
        
    def getFiles(self):
        """
            retrieve all files inside this directory (including subdirectories)
        """
        pass

class Element:
    """
        object representing an element
    """
    def __init__(self, server, production, file):
        self.server = server
        self.production = production
        self.file = file
        self.id = None
        self.name = None
        self.type = None

    def rename(self, newName, execute=True):
        """
            rename this element to newName
        """
        pass
        
    def getReferencesTo(self):
        """
            return a list with all references to this specific element.
        """
        pass
    
class Reference:
    """
        object representing a reference (link between files)
    """
    pass 
